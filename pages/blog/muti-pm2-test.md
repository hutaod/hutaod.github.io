# pm2单个实例和多个实例的区别探索

> [本文也在掘金发布](https://juejin.cn/post/7199299945084928057)

本文主要记录一次探索 pm2 单个实例和多实例的过程和验证结果。也遗留了问题，大佬们有解决办法的希望分享给我一下。

## 背景

前段时间遇到了一个问题：

> 服务器运行一切正常，CPU 使用率和内存使用率都比较低，但是当某一个 Node.js SSR 工程并发高量时，工程的整体性能会变差，也就是同样的请求，服务器处理时间会更久，但其实并发量对于服务器来说，压力仍然很小。

## 思路

这个问题最后也没有解决，但是也有了一些思路：

1. 注意代码细节，不要在 Node.js 服务执行特别耗费性能的功能，但这是一个很被动方法，难以排查和解决；
2. 服务器的压力小，那么是否可以利用服务器的性能，让 Node.js 服务更加稳定？

第一种思路可以对现有核心代码实现进行排查，也可以调整渲染方式来优化性能，比如让页面尽量静态化的方案。

第二种思路出现了一个想法：

> node 服务是用 pm2 启动的，我们服务器上使用一个 pm2 运行了多个 SSR 工程，是不是相互之间也会有一些影响？毕竟 pm2 cluster 模式也只有一个主进程来管理多个项目的多个进程。那么如果有多个 cluster 来管理会不会可以更多的利用服务器资源，来让 nodejs 中每个进程更稳定？

单个 pm2 管理模型（一对多）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff557de564474788b980ce57f9c64b64~tplv-k3u1fbpfcp-watermark.image?)

多个 pm2 管理模型（一对一）：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/113e9edbbe6b4aac9bb1d0077d4696c8~tplv-k3u1fbpfcp-watermark.image?)

## 测试验证

测试对照条件：请求并发量、pm2 启动方式（一对多，还是一对一）
测试主要记录数据点：
- 请求响应时间
- nodejs 所在服务器的吞吐量、服务器CPU、内存资源
- nodejs 进程CPU、内存使用情况、eventloop

然后经过了多轮测试（具体数据不好拿出来），得出的结果却是：

- 不管是单 `一对多` 还是多 `一对一` ，两个工程相互不会直接影响，只会间接性受到服务器性能的影响，且影响很小；
- 失败率(502 bad getway)随着吞吐量的提升而提升；
- 正常吞吐量情况下，两种方式的性能无明显差别；
- 较高吞吐量情况下，`一对一` 方式服务器 CPU 使用率更高一些（不明显），性能表现比 `一对多` 方式会更差一些（也不是很明显），猜测是机器 cpu 使用率会影响性能表现；
- 接近极限吞吐量情况下，`一对一` 方式的吞吐量比 `一对多` 方式的吞吐量高一些，但失败率明显也比 `一对多` 方式高出不少，除去失败情况下，吞吐量相差并不大，反而服务器 CPU 使用率也更高一些。
- 并发请求量突破一定值时，服务器吞吐量可能会变得更低，但服务器 cpu 使用率也不会跑到100%，一般在90%左右会达到一个上限。

## 结论和多 pm2 启动的方式

因此可以从测试的结果推断出一个结论：启动多个 pm2 来管理多个项目，基本上没啥必要，并发量还有性能更多的与服务器自身的性能有关。

不过还是分享一下多个 pm2 启动的方式（多 pm2 启动的代码，这个官方文档上有，但是感觉并不太好找）：

```bash
PM2_HOME='/**/.pm2' pm2 start ecosystem.config.js
```

就是加了一个 `PM2_HOME='/**/.pm2'` 前缀，如果是在当前工程启动，且该实例只服务于本工程，那么可以直接写成 `PM2_HOME='.pm2'`，这样就会在当前工程目录下生成一个 .pm2 文件夹，并以后都可以使用它。

## 结语

最后还是没有解决实际问题，虽然说并没有太大影响，也在使用调整页面渲染等方式来改进页面性能，但还是希望有经验的伙伴们可以分享一下经验，或者有想法的也可以讨论交流一下。
